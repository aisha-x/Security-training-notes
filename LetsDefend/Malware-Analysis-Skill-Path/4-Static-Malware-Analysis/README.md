# LetsDefend: Static Malware Analysis Summary

# **1- Preparation for Course**

## **Essential Topics to Know**

- **Operating System Fundamentals**
- **Networking Basics**
- **Cryptology Basics â†’** https://app.letsdefend.io/training/lessons/introduction-to-cryptography

## **Lab Environment for Static Malware Analysis**

- REmnix â†’ https://remnux.org/
- FlareVM â†’ https://aisha-x.github.io/posts/SettingupMalwareAnalysisLab/

**It is crucial to analyze malware in isolated and virtual systems to prevent the possibility of infecting the host system during analysis.**

# 2- **Introduction to Static Malware Analysis**

**Malware Analysis** is the process of examining malicious software to understand its behavior, purpose, and potential impact. It helps security teams learn how malware works, how it spreads, and which vulnerabilities it may exploit.

The importance of malware analysis lies in its ability to reveal new or unknown security weaknesses that attackers may be exploiting. However, this is only possible when the malware file itself is obtained for investigation.

Malware analysis is generally divided into **two main stages**:

1. **Static Malware Analysis**
2. **Dynamic Malware Analysis**

**Static Malware Analysis** involves examining a malware file **without running it**. Analysts use tools to inspect the file in a controlled environmentâ€”checking metadata, code structure, strings, and embedded resources. This step is performed first and forms the basis for the next stage, **dynamic analysis**, where the malware is executed to observe behavior.

Static analysis is often easier to begin with and can reveal critical clues about how the malware works. To ensure accurate findings, analysts must document all observations carefully, as these insights may play a key role in understanding the malwareâ€™s behavior during dynamic analysis.

# 3- **Packing and Unpacking in Malware Analysis**

**Packing** is the process of transforming an executable file into another form using an algorithm. Attackers and software vendors use packers for different purposes. **Unpacking** is the reverse processâ€”restoring the file back to its original state.

Packing changes the structure of an executable and can provide several advantages:

- **Reduces file size**
- **Hinders static analysis**
- **Makes detection by security tools more difficult**
    
    <img width="790" height="526" alt="image" src="https://github.com/user-attachments/assets/8bfa97ac-95b1-4b47-a62d-37960343f374" />

    

***The image displayed above shows the file structure of a Windows executable file both before and after the process of packing.***

### **How Packed Malware Executes**

When a packed executable runs:

<img width="1283" height="653" alt="image" src="https://github.com/user-attachments/assets/0f18dd63-7995-4099-8fbe-3ce4c24b6e69" />


1. The **entry point** leads to unpacker code, not the original program.
2. The unpacker **decompresses or decrypts** the original executable.
3. The unpacked code is placed into memory.
4. Execution control is passed to the unpacked executable.
5. The original program runs normallyâ€”now from memory.

### **Packers**

A **packer** is the tool or algorithm performing the packing.

Packers may be:

- **Commercial** (used by legitimate developers)
- **Custom-written** (often used by malware authors)
- **Open-source**

Because their usage overlaps, a single packer can compress and encrypt simultaneously.

<img width="1431" height="973" alt="image" src="https://github.com/user-attachments/assets/58ef9ded-3ca2-4745-8405-32ce57f1fb6b" />

### **Types of Packers**

| Type | Purpose | Common Use |
| --- | --- | --- |
| **Compressing Packers** | Reduce file size | Older systems, limited storage/internet |
| **Encrypting Packers (Crypters)** | Encrypt code to prevent static analysis & detection | Very common in malware to stay FUD (fully undetectable) |
| **Protecting Packers (Protectors)** | Prevent reverse-engineering | Used by legitimate software vendors |

### **Detecting Packers**

Before analyzing malware statically, it's important to identify whether the file is packed. Static analysis of packed malware is usually not helpful until it is **unpacked**.

**Detection Methods:**

### **Automatic Tools**

These tools use packer signatures to detect which packer was used:

- **DIE (Detect It Easy)** *(primary example)*
- PEStudio
- PEiD
- ExeinfoPE
- CFF Explorer

However, automatic detection may fail for **custom packers**.

- **Packer Signature List:Â https://github.com/sooshie/packerid/blob/master/userdb.txt**

### **Manual Detection**

Manual detection often involves examining:

- **Section Names** of the executable
- Other structural features

<img width="447" height="421" alt="image" src="https://github.com/user-attachments/assets/1a40ef82-0a59-49e8-9039-e65ab3ac4366" />

Tools for manual analysis include:

- PE-bear
- PEview
- Stud_PE

Example: Certain packers have **unique section names**, which help identify them.

<img width="952" height="682" alt="image" src="https://github.com/user-attachments/assets/465a4a51-e4b9-4a9d-89a0-87ed8a8240f6" />

Â *In the image above, the malware file is opened with the PE-bear tool and its sections are displayed. Upon examining the section names, it is seen that there are section names specified for theÂ "Aspack"Â packer in the table above. This indicates that the malware was indeed packed using theÂ "Aspack"Â packer.*

### **Key Takeaway**

Packed malware must be **identified and unpacked** before meaningful static analysis. Analysts often start with automatic detection tools but should be prepared to investigate manually when dealing with custom or obfuscated packers.

## Q&A

1. **Question:**Â In which packer/protector is the executable packed?

<img width="864" height="622" alt="image" src="https://github.com/user-attachments/assets/866cafe2-b8cc-45b6-a800-a9186b4259c4" />

Ans: *exPressor*

1. **Question:**Â What is the version of the packer used on this executable file?

Ans: *1.6*

1. **Question:**Â What is the specific section name used by the packer on this executable?

<img width="1060" height="768" alt="image" src="https://github.com/user-attachments/assets/b6b18a94-89a7-4a87-b3de-523d384ef03a" />

Ans: *.ex_cod*

# 4- **Unpacking Packed Malware**

<img width="909" height="582" alt="image" src="https://github.com/user-attachments/assets/b886b404-d3ea-43f2-9b9a-1dbee22933a7" />

**As can be seen in the image above, "UPX" packer name is written in the "File Info" section. The sections of the executable file are also as follows:**

<img width="1221" height="866" alt="image" src="https://github.com/user-attachments/assets/074b38d3-b173-48d5-b958-1f08268441d3" />

**The image above displays the section names of the UPX packer. Through analysis of theÂ "File Info"Â andÂ "Section"Â sections, it has been concluded that the malware in question was packed with the UPX packer.**

**Once the packer used has been identified, the next step is to unpack the executable file using the appropriate tool. In the case of UPX packer, since it is an open-source packer, the required tool for unpacking is readily available on the internet. You can access the tool at the following address:**

**UPX:Â https://upx.github.io/**

- **Note: If a different packer was used and no readily available unpacking tool existed, the unpacking process would involve writing custom unpacking code or utilizing dynamic reverse engineering tools to analyze the executable file and extract the unpacked version.**

**The "CFF Explorer" tool includes a UPX unpacker itself, which allows for quick and efficient unpacking directly from the "UPX Utility" section.**

<img width="866" height="595" alt="image" src="https://github.com/user-attachments/assets/6a7aa7bc-4f9f-4049-9142-703247e1a3be" />

After unpacking, Â **the "File Info" field in the "File" menu on the left is checked.**

<img width="789" height="528" alt="image" src="https://github.com/user-attachments/assets/2d93a9fd-4d04-4ee9-8e92-727a452453aa" />

**This change signifies that the executable file has been successfully unpacked. The sections of the unpacked executable file are analyzed and examined:**Â 

<img width="1180" height="863" alt="image" src="https://github.com/user-attachments/assets/1abc2a30-3d14-43f5-8b55-bced476e7ef2" />

**To save the unpacked file, follow the steps "File -> Save As" from the top menu.**

# 5- **File Format Analysis**

Every file has an internal structure known as its **file format**, which tells the operating system how to interpret and run the file. Different file types contain different fields and structures; for example, Windows `.exe` files cannot run on Linux without additional tools because Linux cannot parse the `.exe` format natively.

### **Importance in Malware Analysis**

Knowing a malwareâ€™s file format helps determine:

- **Which operating system it targets**
- **Which programs it needs to run**
- **What attack method might be used**

For example:

- A `.exe` file indicates malware aimed at **Windows**
- A `.docx` file may include **malicious macros**
- A `.pdf` may contain **embedded JavaScript**

This helps analysts choose the correct tools and techniques for further investigation.

**File Formats:Â https://github.com/corkami/pics/blob/master/binary/README.md**Â 

### **File Header and Magic Bytes**

To determine the true file type, analysts inspect the **file header**, particularly the **magic bytes**â€”the first few bytes that uniquely identify the file type.

These can be viewed using **hex editors** like *HxD*.

<img width="1919" height="978" alt="image" src="https://github.com/user-attachments/assets/0c144b7f-6107-4e93-8872-329a7f0885f7" />

Magic bytes are more reliable than file extensions because extensions can be faked.

### **File Extensions and Mismatches**

While file extensions usually indicate format, attackers may:

- **Fake extensions** (e.g., `report.pdf.exe` disguised as `report.pdf`)
    
<img width="697" height="447" alt="image" src="https://github.com/user-attachments/assets/ad941e45-b3df-4369-a24c-fc545f0ade2f" />
    
- **Change file thumbnails** to mislead users
    
    <img width="723" height="424" alt="image" src="https://github.com/user-attachments/assets/913518d1-f009-4f20-b940-097809cc3da3" />

    

This makes the file look harmless while still remaining executable malware.

### **Identifying File Type**

**Automatic Methods:**

Tools like **DROID**, PEStudio, or online services can detect file types quickly, especially when analyzing many files.

<img width="785" height="515" alt="image" src="https://github.com/user-attachments/assets/f9076e98-08be-4a8d-9802-bd7f8118c931" />

However, caution is needed with online tools, since uploading malware may be unsafe.

**Manual Methods:**

If headers are damaged or the file type is custom, analysts use **hex editors** to inspect the signature directly and determine the real format.

<img width="652" height="518" alt="image" src="https://github.com/user-attachments/assets/8ed64a86-3bba-4862-8f08-28aec908310f" />

### **Key Takeaway**

Correctly identifying the **real file format** is essential before continuing with malware analysis. Attackers frequently **disguise file extensions and visual appearance**, so analysts must rely on **file headers and signatures**, not just what the file looks like or is named.

# 6- String **Analysis**

### **Strings Analysis**

A **string** is a sequence of readable characters included in a programâ€™s source code. In malware, strings often reveal important information about the behavior and purpose of the malicious software.

### **Why Strings Analysis Matters**

During static malware analysis, examining embedded strings can provide clues about how the malware operates. From strings, analysts may discover:

- **File names** used or created by the malware
- **File paths** showing where it stores or accesses data
- **IP addresses** (possible C2 communication servers)
- **Domain names** and **URL links** used for data transfer or downloads
- **Security product names** the malware may attempt to evade
- **Cryptographic library references**, suggesting encryption or ransomware activity
- **Windows API function names**, revealing system operations performed by the malware
- **Base64 encoded data**, which must often be decoded to uncover hidden information

These pieces of information help analysts predict the malwareâ€™s behavior without running it.

### **How to Analyze Embedded Strings**

Strings can be extracted using:

### **Command-Line Tools**

- **Sysinternals `strings` tool** can list readable strings from executable files
    
    ```
    strings64.exe -accepteula malwr3.exe | more
    ```
    

### **Graphical Tools (GUI)**

- **BinText** provides a visual interface and search feature for easier inspection.

Both methods help analysts scan through text to identify meaningful or suspicious values such as IP addresses and URLs.

### **Key Takeaway**

Strings analysis is a fundamental and often quick step in static malware analysis. Although the output may be long, searching for key indicators (like IPs, file paths, and cryptographic references) allows analysts to gather early intelligence about what the malware is designed to do.

# 7- **Analyzing Imports and Exports**

### **What Are Imports and Exports?**

- **Imports**
    
    In Windows executables (PE files), *imports* are external functions that the executable needs in order to run.
    
    These functions are not defined inside the program but come from **DLLs (Dynamic Link Libraries)**.
    
    Example:
    
    If a program wants to create a message box, it may import the function `MessageBoxA` from `User32.dll`.
    
- **Exports**
    
    *Exports* are functions provided by a DLL so that other programs can use them.
    
    A DLL may export many functions, and regular .exe files usually do **not** export functions.
    

### **Why Imports and Exports Matter in Static Malware Analysis**

When analyzing malware **without running it**, imports and exports reveal strong hints about the malwareâ€™s **capabilities** and **intended behavior**.

### **Examples:**

| DLL Name | Purpose / What It Indicates in Malware Behavior |
| --- | --- |
| `User32.dll` | Interaction with GUI elements â€” may open windows, show warnings, disable keyboard/mouse, lock screen. |
| `Kernel32.dll` | Core OS functions â€” process creation, memory operations, file handling. |
| `Advapi32.dll` | Registry operations and privilege control â€” could indicate system persistence. |
| `Ws2_32.dll` | Network operations â€” suggests communication with remote servers (possible C2 activity). |
| `Wininet.dll` | Internet communication â€” often used in downloading payloads. |

So, **by looking at imports, we can predict what the malware intends to do.**

For example:

If we see imports like:

```
CreateProcessA
WriteFile
RegSetValueExA
```

We may conclude that the malware can **create new processes**, **write files**, and **modify the Windows Registry** â†’ possible **persistence** behavior.

### **Viewing Imports and Exports**

There are multiple tools to analyze imports/exports of a PE file.

ðŸ”— **PE Studio Download:** https://www.winitor.com/download

# 8- **Digital Signatures for Static Analysis**

### **What is a Digital Signature?**

A **digital signature** on an executable file indicates **which vendor or developer created the file**. It helps distinguish **legitimate** software from **counterfeit or malicious** software.

> Note:
> 
> 
> The cryptographic principles behind digital signatures (how they are mathematically generated and verified) are not covered here.
> 
> To learn that aspect, refer to:
> 
> **Introduction to Cryptology:** https://app.letsdefend.io/training/lesson_detail/digital-signatures
> 

### **Significance of Digital Signatures in Static Malware Analysis**

Digital signatures are used in static analysis to help determine whether an executable is **legitimate or potentially malicious**.

| Case | What It Means |
| --- | --- |
| **File has a valid digital signature from a trusted vendor** | Often indicates that the file is legitimate. |
| **File has *no* digital signature** | Common for malware. This is a **strong suspicious indicator**. |
| **File has a *valid* signature but still behaves maliciously** | Possible **Supply Chain Attack** â€” attackers use the vendorâ€™s real signing certificate. |
| **File has a signature, but the certificate is *invalid* or *revoked*** | Suspicious. This may indicate that the vendorâ€™s certificate has been stolen and misused to sign malware. |

So, while a valid signature is helpful, **it does not guarantee the file is safe** â€” especially in the case of insider threats or supply chain compromise.

### **How to View Digital Signatures on Windows Executable Files**

Windows has built-in features for inspecting digital signatures:

1. **Right-click** the executable file.
2. Select **Properties**.
3. Go to the **Digital Signatures** tab.

<img width="405" height="362" alt="image" src="https://github.com/user-attachments/assets/75465f6b-f994-4ddf-9f46-7f417b1ca1bd" />

**Details of the signature can be viewed with the "Details" button as demonstrated in the above image:**

<img width="405" height="483" alt="image" src="https://github.com/user-attachments/assets/bc2822d2-93c9-4ad1-8c75-7a47d363e20a" />

From here, you can:

- See **who signed the file** (e.g., Google, Microsoft).
- View the **certificate details** using the **Details** button.

This allows verification of:

- Issuer (who issued the certificate)
- Certificate validity dates
- Whether the certificate belongs to the expected vendor

### **Verifying Signature Validity Using VirusTotal**

You can also verify whether the signature is trustworthy via **VirusTotal**:

1. Upload the file to VirusTotal.
2. After the scan completes, open the **Details** tab.
3. Review the **Signature Information** section.

<img width="661" height="623" alt="image" src="https://github.com/user-attachments/assets/01e11e8c-05fd-4997-ad90-1604a65169dd" />

If the signature is valid and recognized, VirusTotal will confirm it.

# 9- **Resource Analysis**

### **What is a Resource?**

A **resource** is any embedded asset stored inside a Windows executable file.

Common resource types include:

- Icons
- Images
- Dialog boxes
- Strings
- Configuration files
- Even **other executable files**

These resources are included so the program can use them when needed during execution.

### **Why Resource Analysis is Important in Static Malware Analysis**

Resource analysis can reveal **hidden components or payloads** that the malware carries with it.

For example:

- A malware sample may store **another malicious executable** inside its resources.
- By extracting and analyzing that embedded file, we can learn what **additional malicious actions** the malware performs.

So, inspecting resources can provide **valuable clues** about the malwareâ€™s purpose and behavior before executing it.

### **How to Analyze Resources in Windows Executables**

A common tool for resource analysis is **Resource Hacker** (GUI based).

**Download:** http://www.angusj.com/resourcehacker/

**Steps:**

1. Open Resource Hacker.
2. Select **File â†’ Open**.
3. Choose the executable to analyze.
4. The tool will display the resource sections, allowing you to browse and extract them.

<img width="786" height="428" alt="image" src="https://github.com/user-attachments/assets/42430e21-29c6-48e6-a900-d92d679b1fb1" />

This lets analysts inspect any embedded icons, strings, and possibly **hidden executable files**.

### **Other Useful Tools for Resource Analysis**

| Tool | Link | Notes |
| --- | --- | --- |
| **CFF Explorer** | https://ntcore.com/?page_id=388 | PE structure and resource viewer |
| **PE-Bear** | https://github.com/hasherezade/pe-bear | Lightweight PE inspector for malware analysis |
| **PE Studio** | https://www.winitor.com/download | Also used for imports/exports and suspicious indicators |

### **Key Takeaway**

Resource analysis helps analysts identify **hidden payloads and supporting files** inside malware. This makes it an essential step in **static malware analysis**, providing insights without executing the malware.
