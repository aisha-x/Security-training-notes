# letsDefend: Reverse Engineering 1 summary

# **1- Preliminary Information about Reverse Engineering Fundamentals Course**

**Cyber threats identified by SOC analysts can sometimes go far beyond the network access and network breach. Threat Hunters who are actually the Blue Team members can detect malware on servers or endpoints within the organization. It is very important to obtain detailed information about the activities of the malicious element detected to eradicate it from the network before spreading to other systems and reduce the damage that may cause in the organization. After the malicious file is exported from the infected system, it is delivered to the Malware Analyst, a SOC member, for analysis. Malware Analyst examines the malware with reverse engineering techniques in order to detect the malicious activities of the malware. This is simply how the malware behaviors are analyzed and necessary actions and precautions are taken.**

# 2- **Introduction to Reverse Engineering**

## Table of Contents:

- **Reverse Engineering Basics**
- **Basic Concepts**
- **Memory Layout**
- **Sample C Program**
- **C Binary Decompiling with Ghidra**

# **3- Reverse Engineering Basics**

Reverse engineering is the process of analyzing a program to understand how it works, usually at the assembly or low-level code. It is commonly used in cybersecurity to study malware behavior when the original source code is not available.

Because reverse engineering is time-consuming, it should be done when the malware is relevant to the organization’s assets and threats. The goal is to understand how the malware operates, improve SOC detection capabilities, and take preventive measures.

In blue team operations, reverse engineering is essential for identifying malware techniques and system impacts, helping defenders strengthen security monitoring and incident response.

A safe reverse engineering lab should be set up in an isolated virtual environment to avoid infecting real systems. The operating system and tools used should match the type of file being analyzed (e.g., Windows tools for .exe files).

Key tools used in a Linux reverse engineering lab include:

- **file** – identifies file type
- **objdump** – disassembles binaries to view assembly code
- **gcc** – compiles C programs for analysis
- **gdb** – dynamically debugs programs to observe runtime behavior

# 4- **Basic Concepts**

**Compiling** is the process of converting high-level source code into machine code so it can be executed on a computer (e.g., producing `.exe` files in Windows).

**Decompiling** is the attempt to convert an executable file back into its original source code. However, decompiling is often difficult because developers use techniques to protect their code. Tools commonly used to decompile .NET applications include ILSpy, dotPeek, .NET Reflector, and JustDecompile.

<img width="778" height="347" alt="image" src="https://github.com/user-attachments/assets/e5af2dc4-6072-42a8-9cd9-d101fbcc4f79" />

## **C# Binary Decompile Example with ILSpy Tool**

We will use the “ILSpy” tool in this example to decompile the executable file written in C# programming language. This is a tool that runs on Windows systems and has a graphical user interface (GUI). You can access the non-installation file of the ILSpy tool using the link below:

ILSpy: https://github.com/icsharpcode/ILSpy/releases/download/v8.0-preview3/ILSpy_binaries_8.0.0.7246-preview3.zip

Note: “.NET 6.0” must be installed on your Windows system in order to be able use the ILSpy tool on the link above. “ILSpy” and “.NET 6.0” installation files are located in the “CourseFiles” directory in the Linux system, which is included in the following parts of the training.

Let's start with the example:

<img width="467" height="314" alt="image" src="https://github.com/user-attachments/assets/357b7ea6-0960-4d5f-a953-4ea021ceff45" />

**Note: You can access the “LetsDefend.exe” file in the example on the “CourseFiles” directory in the Linux system, which is included in the following parts of the training.**

**Let's run the "LetsDefend.exe" file shown in the image above.**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/4.Basic+Concept/terms3.png)

**The window you see above pops open when the program is run. Let's see what the program does:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/4.Basic+Concept/terms4.gif)

**As seen in the image above, the program shows an image when the “Click Me” button is clicked. So, let's open the "ILSpy" tool to reveal the source code of the program with the decompile process to be able to reveal how this happens or through what code it does happen.**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/4.Basic+Concept/terms5.png)

**The window you see above will pop open when the ILSpy tool is run.**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/4.Basic+Concept/terms6.png)

**We can upload our file to the program using "File -> Open" option.**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/4.Basic+Concept/terms7.png)

**As you can see the image above, the decompile process starts and after the program is uploaded into the ILSpy tool. We can use the navigation menu on the left to see what happens when the button is clicked through the source code:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/4.Basic+Concept/terms8.png)

**As seen in the source code in the image above, the invisible picture box becomes visible when the button is clicked.**

**We have obtained the source code of the program which was written in C# language with the help of the ILSpy tool and the exact function of the button in the code was revealed.**

**Assembler** is a tool that converts assembly language code into machine code. An example is **NASM** (Netwide Assembler).

**Disassembler** does the opposite—it converts machine code back into assembly language. Examples include IDA Pro, Hopper, Binary Ninja, and objdump.

**Debugging** is the process of analyzing a program step-by-step while it runs to understand its behavior, test functionality, or study program flow during reverse engineering. Tools used for debugging include OllyDbg, Immunity Debugger, GDB, IDA Pro, x64dbg, and WinDbg.

# 5- Memory Layout

### **What is Memory?**

Memory (RAM) is hardware used to temporarily store data while programs are running. When the computer starts, the operating system and running programs are loaded into memory so the processor can access them quickly. Memory is essential because programs need a place to store and work with data while they execute.

- **More info about memort → Memory Forensics: https://app.letsdefend.io/training/lessons/memory-forensics**

### **Stack vs. Heap**

When a program runs, it uses two main memory areas:

| Area | Purpose | Type of Data | Size / Behavior |
| --- | --- | --- | --- |
| **Stack** | Stores temporary data during function execution | Local variables, function parameters | Small, fast, automatically managed |
| **Heap** | Stores data created dynamically at runtime | Objects created with `malloc`, `new`, etc. | Larger, slower, manually managed |
- The **Stack** grows **downward** (from high addresses to low addresses).
- The **Heap** grows **upward** (from low addresses to high addresses).

<img width="821" height="741" alt="image" src="https://github.com/user-attachments/assets/ed9b30f2-c488-42cc-91c9-495167930b8c" />

### **How the Stack Works (LIFO)**

The stack uses the rule **Last In, First Out (LIFO)**.

| Operation | Meaning |
| --- | --- |
| **Push** | Add a new value to the top of the stack |
| **Pop** | Remove the most recent value from the stack |

Example:

- Push A → Push B → Push C
- Pop → returns C (because it was the last inserted)

### **What is Endianness?**

Endianness describes how multibyte data (like integers) is stored in memory.

| Type | Description | Example (for number 0x12345678) |
| --- | --- | --- |
| **Big Endian** | Stores the **most significant byte first** | `12 34 56 78` |
| **Little Endian** | Stores the **least significant byte first** | `78 56 34 12` |

Most modern CPUs (like Intel) use **Little Endian**.

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/5.Memory+Layout/mem4-edited.png)

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/5.Memory+Layout/mem5-edited.png)

*(Image Source: https://en.wikipedia.org/wiki/Endianness)*

# 6- **Sample C Program**

## **About C Programming**

C is a widely used programming language developed in the 1970s. It is closer to the operating system compared to higher-level languages, but easier to work with than Assembly. Because of its low-level nature, learning C helps greatly in reverse engineering — many malware and system programs are written in C, and recognizing common C functions is useful when analyzing binaries.

In this training, examples are written in C because understanding C makes it easier to understand how a compiled program behaves at the machine and assembly level.

### **How a C Program Becomes an Executable**

When C source code is compiled, it goes through several stages before becoming an executable file:

| Stage | Result | Description |
| --- | --- | --- |
| **Pre-processing** | `.i` file | Removes comments and handles `#include` and `#define` statements. |
| **Compilation** | `.s` file | Converts the pre-processed code into assembly language. |
| **Assembling** | `.o` or `.obj` file | Converts assembly code into machine code (object file). |
| **Linking** | `.exe` (Windows) / executable (Linux) | Combines object files with required libraries to create the final executable program. |

```
.c → .i → .s → .o → .exe
```

- On **Windows**, executables usually end in **`.exe`**.
- On **Linux**, the output may have **no file extension** (often shown as `a.out` or custom name

## Compiling C Source Code with GCC

**After briefly mentioning the compile process of the C programming language, let's see how to compile the C source code with the ".c" extension using "GCC" in this section.**

**First, type "Hello World!" on the command line. Let's see the source code of the program that prints it:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/6.Sample+C+program/cpro2.png)

**As seen in the image above, a source code with a simple print operation was written in C programming language and saved as a "helloworld.c" file.**

**Note: It usually comes pre-installed by default in “GCC” Linux distros, and it may need to be installed later in some Linux distros. For example, we will need to have it installed in the “Debian” used in this training as it is not installed in it. The following command can be used in Debian-based some Linux distros to install the GCC tool:**

**Install GCC: sudo apt-get install gcc-multilib**

**Let's compile this source code with GCC:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/6.Sample+C+program/cpro3.png)

**As seen in the image above, GCC and C source code were successfully compiled and an executable file named "helloworld" was created. The meanings of the parameters in the command are as follows:**

- **m32: This parameter allows compile to 32-bit systems. This parameter is required because 32-bit executable files are used in the training.**
- **o: This is the parameter that gives the name of the file as output.**

**Compile Command: sudo gcc -m32 helloworld.c -o helloworld**

**Let's see the print operation by running the file:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/6.Sample+C+program/cpro4.png)

**As you can see in the image above, the file was successfully run.**

**Note: The “helloworld.c” source code file and the “helloworld” executable binary file shown above are located under the “CourseFiles” directory in the Linux system, which is included in the later parts of the training.**

## Reviewing the C Source Code

**We covered the stack and heap fields in the previous topics. We will exemplify the elements in the stack and heap area over the C code in this topic:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-1/6.Sample+C+program/cpro5.png)

**As can be seen in the image above, the status of the variables in the stack or heap can change depending on the fact that there are many different qualities in the C code. Variables named “a” and “y” defined as local variables are located in the stack area. Also, the variable named "x", which is defined as the function parameter is another example for a variable in the stack area. On the other hand, "global_variable", which is defined as a global variable is the example for the variables in the Heap field. In addition, the variable named “static_var”, which is defined as static, is also included in the heap area. Finally, another variable in the heap field is the variable named “z”, which is defined as an integer pointer. The reason why this variable is in the heap field is that the function named “malloc”, which is one of the dynamic allocation functions, is used. In addition to the malloc function, the C functions named calloc, free and realloc can be given as examples of functions used for dynamic memory allocation purposes.**

**Note: The “example1.c” source code file shown above is located under the “CourseFiles” directory in the Linux system, which is included in our training later on.**
