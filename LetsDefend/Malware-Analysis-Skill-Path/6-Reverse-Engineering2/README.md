# LetsDefend: Reverse Engineering 2 summary

**The reverse engineering course offers a comprehensive exploration of various topics, including registers, X86 Assembly language, CPU instructions, GNU debugger, and debugging with GDB, providing students with the necessary knowledge and skills to dissect and understand software from a reverse engineering perspective.**

## Table of Contents:

- Registers part 1
- Registers part 2
- x86 Assembly Language and CPU Instructions
- CPU Instructions part 2
- GNU Debugger (GDB)
- Debugging with GDB

# Registers part 1 & 2

### **What are Registers?**

Registers are small, fast storage locations inside the CPU. They hold data needed for program execution. In x86 architecture, registers are typically 32 bits.

### **Types of Registers**

### **1. General Purpose Registers**

Used for arithmetic, data storage, counting, and memory addressing.

| Register | Purpose |
| --- | --- |
| **EAX** | Main accumulator; stores results of arithmetic and function returns. |
| **EBX** | holds the base address of the program. |
| **ECX** | Counter register used in loops. |
| **EDX** | Data register; used in I/O operations and arithmetic. |

### **Pointer Registers**

These hold memory addresses, especially related to the stack and instruction flow.

| Register | Purpose |
| --- | --- |
| **EBP** | **holds the lowest address of the Stack and is used for local variables.** |
| **ESP** | Points to the *top* of the stack. |
| **EIP** | Points to the *next instruction* to be executed. (Controls program flow) |

### **Index Registers**

Used in string and memory operations.

| Register | Purpose |
| --- | --- |
| **ESI** | Source memory index. It holds the address of where the data will be read. |
| **EDI** | Destination memory index.It holds the address of where the data will be written. |

### **Segment Registers**

These hold the memory segment locations.

| Register | Segment Purpose |
| --- | --- |
| **SS** | Stack segment. holds the base location address of the stack. |
| **CS** | Code segment (`.text`, instructions). holds the address of the code segment used for data access. |
| **DS** | Data segment (`.data`, variables). holds the address of the data segment which is the default variable location for data access. |
| **ES** | Extra segment for string operations. |

### **EFLAGS Register (Status Flags)**

Each bit in EFLAGS represents a condition that affects CPU behavior.

| Flag | Meaning |
| --- | --- |
| **CF** | Carry occurred in arithmetic. |
| **ZF** | Result is zero. |
| **SF** | Result is negative. |
| **OF** | Signed overflow happened. |
| **PF** | Indicates if number of 1 bits is even. |
| **DF** | Direction of string operations. **left to right → DF = 0, right to left → DF=1** |
| **IF** | Enables or disables external interrupts. |
| **AF** | Assists in BCD (rare today). |
| **TF** | Enables single-step debugging. |

---

**In short:**

Registers help the CPU store temporary data, control program flow, handle memory operations, and keep track of the results of instructions. Understanding them is essential in reverse engineering, debugging, and malware analysis.

# **x86 Assembly Language and CPU Instructions**

### **What is x86 Assembly Language?**

Assembly language is a human-readable representation of machine code, and each processor architecture has its own assembly language. The x86 assembly language corresponds to Intel-based processors.

Assembly is harder to read and write compared to high-level programming languages, but it is essential when analyzing programs at the processor level — for example, during reverse engineering and debugging.

## **AT&T Syntax vs. Intel Syntax**

There are different ways to write x86 assembly instructions; two common formats are:

- **AT&T Syntax**
- **Intel Syntax** (the one we will use)

Both syntaxes represent the same instructions, just with different formatting.

### **AT&T Syntax Example**

When using tools like `objdump` without options, you may see AT&T syntax. Characteristics include:

- Register names start with `%` (e.g., `%eax`)
- The **source → destination** order is reversed compared to Intel syntax
- Example command to view AT&T syntax:
    
    ```bash
    sudo objdump -d helloworld
    ```
    

### **Intel Syntax Example**

Intel syntax is cleaner and easier to read:

- No `%` signs in register names
- Instructions follow **destination ← source** order
- Example command to view Intel syntax:
    
    ```bash
    sudo objdump -d -M intel helloworld
    ```
    

## **Addressing Modes in Assembly**

Assembly instructions can work with values stored in registers, immediate values, or memory.

| Addressing Mode | Example | Meaning |
| --- | --- | --- |
| **Register Addressing** | `MOV EAX, EBX` | Move value from EBX to EAX |
| **Immediate Addressing** | `MOV EAX, 0x0` | Load constant 0 into EAX |
| **Memory Addressing** | `MOV EAX, DWORD PTR [ESP]` | Load a value from memory at address ESP |

## **CPU Instructions (Part 1)**

### **Arithmetic Instructions**

| Instruction | Description | Example | Effect |
| --- | --- | --- | --- |
| `ADD` | Addition | `ADD ESP, 0x8` | ESP = ESP + 8 |
| `SUB` | Subtraction | `SUB ESP, 0x4` | ESP = ESP - 4 |
| `MUL` | Multiplication | `MUL EBX` | EAX = EAX × EBX |
| `DIV` | Division | `DIV ECX` | EAX = EAX ÷ ECX |
| `INC` | Increment by 1 | `INC EBX` | EBX = EBX + 1 |
| `DEC` | Decrement by 1 | `DEC EBX` | EBX = EBX - 1 |
| `CALL` | function call. | **`CALL 0x56556199`** | the function named “`0x56556199`” is called |
| **`CMP`** | compare | **`CMP EDX, EAX`** | compare **EAX and EDX registers.**  |

The `CALL`instruction has **2 basic operations with this instruction `CALL 0x56556199`:**

- The address of the instruction after the CALL instruction in the program flow is pushed to the stack (Return address)
- The value of the EIP register is set as the function address, so that the program flow branches to the corresponding function.

CMP instruction:

```nasm
**CMP    EDX, EAX**
```

The above instruction compares the EAX and EDX registers. Depending on the result of the comparison, “Zero Flag(ZF)” and “Carry Flag(CF)” may be changed.

### **Branch Instructions (Program Flow Control)**

| Instruction | Condition for Jump | Meaning |
| --- | --- | --- |
| `JMP` | None (Always jumps) | Unconditional jump |
| `JZ` / `JE` | Zero Flag = 1 | Jump if equal / jump if result was zero |
| `JNZ` / `JNE` | Zero Flag = 0 | Jump if not equal / result not zero |

Example:

```nasm
JE 0x5555555551b5   ; Jump only if ZF = 1
```

# **CPU Instructions (Part 2)**

### **Data Transfer Instructions**

| Instruction | Description | Example | Meaning |
| --- | --- | --- | --- |
| `MOV` | Move data | `MOV EAX, 0x0` | EAX = 0 |
| `LEA` | Load address (not value) | `LEA ECX, [ESP+0x4]` | ECX = address (ESP + 4) |
| `XCHG` | Swap register values | `XCHG EAX, EBX` | Swap EAX and EBX |
| `PUSH` | Push to stack | `PUSH EDX` | ESP decreases, EDX placed on stack |
| `POP` | Pop from stack | `POP EDX` | Top stack value removed and stored in EDX |

example of `push`instruction `**PUSH   EDX**`

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/11.CPU+Instructions+-+2/cpu1.gif)

**As seen in the image above, the value in the EDX register has been successfully added to the stack with the "PUSH" instruction.**

**`POP    EDX`**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/11.CPU+Instructions+-+2/cpu2.gif)

**As seen in the image above, the data at the top of the stack has been removed from the stack using the "POP" instruction and assigned to the EDX register successfully.**

### **Logical Instructions**

| Instruction | Description | Example | Effect |
| --- | --- | --- | --- |
| `AND` | Bitwise AND | `AND ESP, 0xfffffff0` | Clears lower bits (alignment) |
| `OR` | Bitwise OR | `OR EAX, 0xfffffff0` | Sets lower bits |
| `XOR` | Bitwise XOR | `XOR EBP, EBP` | Sets EBP to 0 (common zeroing trick) |
| `NOT` | Bitwise NOT | `NOT EAX` | Inverts bits |

### **NOP**

`NOP` = *No Operation*

Used to fill space and change timing without affecting behavior.

## **What is an Opcode(Operation Code)?**

Opcode(Operation Code) is a unique value that belongs to each instruction. Thanks to this value, the machine understands which instruction to execute. The following image shows the opcodes of the instructions according to the x86 architecture:

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/11.CPU+Instructions+-+2/cpu3.png)

*(Image Source: https://stackoverflow.com/questions/67586535/encoding-x86-16-instruction-with-immediate-operand)*

**Opcodes are usually expressed in hexadecimal notation. For example, let's see the opcode of the "NOP" instruction according to the image above:**

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/11.CPU+Instructions+-+2/cpu4.png)

After finding the "NOP" instruction on the image, we should first look at its equivalent on the left lines: "9", then, check the column equivalent at the top: “0”. The combination of these hexadecimal values creates the opcode: “0x90”.

# **GNU Debugger (GDB)**

## What is GDB?

GNU Debugger (GDB) is a reverse engineering tool that enables debugging Linux executable files on the Linux command line.

## PEDA (Python Exploit Development Assistance) Plugin Installation

There are some specific plugins to use the gdb tool with a more understandable user interface. One of them is the PEDA (Python Exploit Development Assistance) plugin. This plugin provides a more colorful and more understandable interface to the user during debugging. The PEDA plugin can be downloaded from:

- **PEDA: https://github.com/longld/peda**

Clone the plugin:

```bash
git clone https://github.com/longld/peda.git ~/peda
```

Open the gdb tool with the PEDA plugin

```bash
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

## Basic GDB Commands

Below are the basic commands that we must know in order to use the gdb tool:

- Note: We will use the executable file named “helloworld” that we also used in the previous parts of the training to apply the commands here.

### Help command:

```bash
help all
```

### **File Command**

**After opening the gdb tool, the file to be debugged is given to the program with the below file command:**

```bash
**file helloworld**
```

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb9.png)

### **Info Command**

After the file is given to gdb with the file command, it should be determined where the program flow will be stopped. Generally, executable files written in C programming language are started to be debugged from the "main" function:

The “info” command is that the one that provides information in accordance with the given parameter. For example, let's see the functions in the executable file with this command:

```bash
**info functions**
```

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb10.png)

### **Break (or b) Command**

The points where the program flow will be stopped on gdb are called "breakpoints". The command used to set a breakpoint is the "break" or "b" command for short. The break command can be given an address or a function name as a parameter. Let's put a breakpoint in the "main" function seen in the output of the previous command:

```bash
**break main**
```

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb11.png)

As it can be seen in the screenshot above, a breakpoint has been placed in the main function successfully.

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb12.png)

The "info breakpoints" command can display all the set breakpoints as you can see in the image above.

### **Run Command**

The gdb commands so far are the commands applied before the executable file named “helloworld” is run. The program is executable after the breakpoint is set.

The “run” command is to "run" the executable. Let's start the debugging process by executing the command:

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb13.png)

The see the main screen during the debugging process on gdb on the image above. There are 3 sections on this screen: RegistersCodeStack

- **Registers**: is the field that displays the current values of the registers after each instruction execution.
- **Code**:  is the field where the executed instructions in the program flow are located.
- **Stack**: is the field where the elements in the stack data structure are displayed.

### **Nexti(ni) and Stepi(si) Commands**

“nexti(`ni`)” and “stepi(`si`)” are vitally important commands to be able to execute each instruction in the program flow. 

A single instruction is executed with the "nexti(`ni`)" command and changes are applied to the relevant register or data fields. With this command will not enable us to get into the functions called with the "`call`" instruction. If the next instruction to be executed is "`call`" and it is needed to get into the called function, the "stepi(`si`)" command should be executed.

For example, in the previous image, we saw that the "call" instruction will be executed in the program flow. Let's go inside the function called with the "`si`" command:

- Note: Let's set a breakpoint at the address of the instruction after the "call" instruction in the main function, so that we can go back to where we left off in the main function after entering the function called with "call":

Command: 

```bash
b *0x565561ad
```

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb14.png)

- Note: As you can see in the image above, "*" sign is prefixed to the address when setting breakpoints to memory addresses.

Let's enter into the function with the "`si`" command after setting up the breakpoint:

<img width="1011" height="758" alt="image" src="https://github.com/user-attachments/assets/0d06b50b-4c38-4fe2-990a-e3d9e8006b24" />

*The above screenshot shows that the function has been entered successfully.*

### **Continue Command**

“`Continue`” is the command that should be used to execute the instructions up to the breakpoint, which was previously left in order to return to the main function. It can be abbreviated and use as "`c`". Let's run the instructions up to the breakpoint in the main function with the “continue” command:

![](https://letsdefend-images.s3.us-east-2.amazonaws.com/Courses/Reverse-Engineering-2/12.GNU+Debugger+(GDB)/gdb16.gif)

*The above screenshot shows that the program was run successfully until the breakpoint with the "continue" command.*

## **Set Command**

In some cases, we may need to interfere with the program flow during debugging. For example, we may need to jump the program flow directly to a different instruction. In this case, we need to change the value of the EIP register using the "`set`" command. Let's set the value of the EIP register to a different address using the set command:

Command: 

```bash
set $eip=0x565561bb
```

- Note: When assigning values to registers, a "`$`" sign must be prefixed the register name in the command.

<img width="949" height="807" alt="image" src="https://github.com/user-attachments/assets/74fc2233-19d9-4cf1-9c3a-849fc83ca40a" />

*The above screenshot shows that the value of the `EIP` register has been changed successfully and the program flow has been interfered with.*

- Note: The "context" command used in the screenshot above is used to show the current information on the debugging screen.

### **Quit Command**

**“`Quit`**” is the command to close the gdb tool.

- Note: The GDB tool can be used online at at its own website below. Online GDB: https://www.onlinegdb.com/

# **Debugging with GDB**

**Example of Debugging with GDB**

**Before starting the reverse engineering process, it is necessary to obtain some information about the executable file to be analyzed. Such as**

- Operating system the executable file was compiled for
- ****the type of the file
- which programming language it was written in
- whether anti-reversing techniques were applied or not

In this example we will use pincode file that asks the user for the correct pin code and our goal is to figure out the correct pin code by reverse engineering the file using GDB.  

```bash
root@ip-172-31-39-48:~/Desktop/CourseFiles# file pincode 
pincode: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=557a3c8bca2794bd0a435d364cb44bb94f92ccd4, for GNU/Linux 3.2.0, not stripped
root@ip-172-31-39-48:~/Desktop/CourseFiles# 
```

String command so we know what programming language the file is written in by observing the functions and files

<img width="1150" height="776" alt="image" src="https://github.com/user-attachments/assets/1b3a4833-9596-4c6f-97ed-d51ca0bcded5" />

As we can see, we found two functions that belong to c programming language

```bash
sudo objdump -d pincode -M intel
```

```nasm
000011b9 <main>:
    11b9:	8d 4c 24 04          	lea    ecx,[esp+0x4]
    11bd:	83 e4 f0             	and    esp,0xfffffff0
    11c0:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
    11c3:	55                   	push   ebp
    11c4:	89 e5                	mov    ebp,esp
    11c6:	53                   	push   ebx
    11c7:	51                   	push   ecx
    11c8:	83 ec 10             	sub    esp,0x10
    11cb:	e8 f0 fe ff ff       	call   10c0 <__x86.get_pc_thunk.bx>
    11d0:	81 c3 30 2e 00 00    	add    ebx,0x2e30
    11d6:	c7 45 f4 00 00 00 00 	mov    DWORD PTR [ebp-0xc],0x0
    11dd:	83 ec 0c             	sub    esp,0xc
    11e0:	8d 83 08 e0 ff ff    	lea    eax,[ebx-0x1ff8]
    11e6:	50                   	push   eax
    11e7:	e8 44 fe ff ff       	call   1030 <printf@plt>
    11ec:	83 c4 10             	add    esp,0x10
    11ef:	83 ec 08             	sub    esp,0x8
    11f2:	8d 45 f4             	lea    eax,[ebp-0xc]
    11f5:	50                   	push   eax
    11f6:	8d 83 17 e0 ff ff    	lea    eax,[ebx-0x1fe9]
    11fc:	50                   	push   eax
    11fd:	e8 5e fe ff ff       	call   1060 <__isoc99_scanf@plt>
    1202:	83 c4 10             	add    esp,0x10
    1205:	8b 45 f4             	mov    eax,DWORD PTR [ebp-0xc]
    1208:	3d 96 1b 00 00       	cmp    eax,0x1b96
    120d:	75 14                	jne    1223 <main+0x6a>
    120f:	83 ec 0c             	sub    esp,0xc
    1212:	8d 83 1a e0 ff ff    	lea    eax,[ebx-0x1fe6]
    1218:	50                   	push   eax
    1219:	e8 22 fe ff ff       	call   1040 <puts@plt>
    121e:	83 c4 10             	add    esp,0x10
    1221:	eb 24                	jmp    1247 <main+0x8e>
    1223:	83 ec 0c             	sub    esp,0xc
    1226:	8d 83 25 e0 ff ff    	lea    eax,[ebx-0x1fdb]
    122c:	50                   	push   eax
    122d:	e8 0e fe ff ff       	call   1040 <puts@plt>
    1232:	83 c4 10             	add    esp,0x10
    1235:	83 ec 0c             	sub    esp,0xc
    1238:	8d 83 2e e0 ff ff    	lea    eax,[ebx-0x1fd2]
    123e:	50                   	push   eax
    123f:	e8 fc fd ff ff       	call   1040 <puts@plt>
    1244:	83 c4 10             	add    esp,0x10
    1247:	b8 00 00 00 00       	mov    eax,0x0
    124c:	8d 65 f8             	lea    esp,[ebp-0x8]
    124f:	59                   	pop    ecx
    1250:	5b                   	pop    ebx
    1251:	5d                   	pop    ebp
    1252:	8d 61 fc             	lea    esp,[ecx-0x4]
    1255:	c3                   	ret    
    1256:	66 90                	xchg   ax,ax
    1258:	66 90                	xchg   ax,ax
    125a:	66 90                	xchg   ax,ax
    125c:	66 90                	xchg   ax,ax
    125e:	66 90                	xchg   ax,ax

```

<img width="610" height="797" alt="image" src="https://github.com/user-attachments/assets/60f15c6e-d3f6-47df-8f69-4df9366809cf" />

```bash
gdb-peda$ b main
Breakpoint 1 at 0x11c8
gdb-peda$ run
Starting program: /root/Desktop/CourseFiles/pincode 
[----------------------------------registers-----------------------------------]
EAX: 0xf7fb5088 --> 0xffffd2fc --> 0xffffd4a9 ("SHELL=/bin/bash")
EBX: 0x0 
ECX: 0xffffd260 --> 0x1 
EDX: 0xffffd284 --> 0x0 
ESI: 0xf7fb3000 --> 0x1e8d6c 
EDI: 0xf7fb3000 --> 0x1e8d6c 
EBP: 0xffffd248 --> 0x0 
ESP: 0xffffd240 --> 0xffffd260 --> 0x1 
EIP: 0x565561c8 (<main+15>:	sub    esp,0x10)
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x565561c4 <main+11>:	mov    ebp,esp
   0x565561c6 <main+13>:	push   ebx
   0x565561c7 <main+14>:	push   ecx
=> 0x565561c8 <main+15>:	sub    esp,0x10
   0x565561cb <main+18>:	call   0x565560c0 <__x86.get_pc_thunk.bx>
   0x565561d0 <main+23>:	add    ebx,0x2e30
   0x565561d6 <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
   0x565561dd <main+36>:	sub    esp,0xc
[------------------------------------stack-------------------------------------]
0000| 0xffffd240 --> 0xffffd260 --> 0x1 
0004| 0xffffd244 --> 0x0 
0008| 0xffffd248 --> 0x0 
0012| 0xffffd24c --> 0xf7de4ed5 (<__libc_start_main+245>:	add    esp,0x10)
0016| 0xffffd250 --> 0xf7fb3000 --> 0x1e8d6c 
0020| 0xffffd254 --> 0xf7fb3000 --> 0x1e8d6c 
0024| 0xffffd258 --> 0x0 
0028| 0xffffd25c --> 0xf7de4ed5 (<__libc_start_main+245>:	add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x565561c8 in main ()
gdb-peda$ 

FullscreenSettings
Disconnect
___________________________________________________________________________________________________

```

<img width="1256" height="882" alt="image" src="https://github.com/user-attachments/assets/0f8a4347-a8fb-4977-9fc9-13693b749182" />

Since the value we want to find in the program flow is the PIN code, we must find the assembly instruction with the comparison in the verification part. For this, we can use the processes we know that are in the program flow as a reference. For example, there are some string values that are printed on the command line and we the user input is received as well. We will have to move forward the program flow as the PIN code comparison comes later than these operations. Let's advance the program flow to the desired section by executing the "ni" command as required:

keep executing ni till you find the printf that print the output

<img width="1245" height="832" alt="image" src="https://github.com/user-attachments/assets/9dc7cfe3-5d77-4880-9b9d-977fb42d8f58" />

As seen in the image above, the "printf" function which was used for command line printing process was detected. Let's find the part that we received the user input by advancing the program flow with the "ni" command:

keep executing ni command till you see this 

<img width="1217" height="801" alt="image" src="https://github.com/user-attachments/assets/4832a33d-5b92-478d-aad2-0bf0a657c70a" />

in the image above, we can see that the user input is passed into the EAX register then it compared with the hex value 0x1b96 (7062 in decimal), so the correct pin number is `7062` 

<img width="491" height="148" alt="image" src="https://github.com/user-attachments/assets/40b38a8a-77fb-4bbf-aedd-c2fefa2fc0d0" />

<img width="1209" height="808" alt="image" src="https://github.com/user-attachments/assets/b191bb31-8711-492a-a147-733259b5ab2e" />

Note that when I passed 5555 (15b3 in hex) as input, in the register section, it passed to the EAX register, and in the code section my input that is saved in the EAX is compared with the correct pin code (0x1b96), then it will check and JNE(jump if not equal to the address `0x56556223`)

<img width="956" height="246" alt="image" src="https://github.com/user-attachments/assets/e3cd8d7e-2ec5-40ff-94ac-6dba375eaf86" />

## Q&A

**Q1. What is the name of the function that starts with “da…” in the “pincode2” executable file?**

load the binary into GDB and run the info function command to list all the functions inside the binary:

<img width="982" height="802" alt="image" src="https://github.com/user-attachments/assets/1ab36759-387c-4b26-b5a3-6d060e48ab09" />

*Ans: dashboard*

**Q2. What is the instruction in “main+45”?**

Break at the main function and run it

```bash
gdb-peda$ b main 
Breakpoint 1 at 0x13a1
gdb-peda$ run

```

keep running the ni command till you reach the main+45, and the instruction in this address is push EAX into the stack 

<img width="1276" height="772" alt="image" src="https://github.com/user-attachments/assets/63c67bf6-8e5f-446d-8c34-49f4628c6d66" />

*Ans: PUSH*

**Q3. Where exactly is the function in which the pincode is taken from the user as an input in the main function?**

The `scanf()` function in C is a standard input function used to read formatted data from the standard input stream. So search for this function

<img width="1399" height="811" alt="image" src="https://github.com/user-attachments/assets/3ca98ddf-e547-4c4b-9700-425e50f7bdd7" />

*Ans: main+68*

**Q4. Which instruction checks whether the entered pin code is correct or not?**

keep executing the ni command till you see the to the CMP compare instruction that will compare our input to a fixed value

<img width="1304" height="750" alt="image" src="https://github.com/user-attachments/assets/c0c1d3b0-4a8a-4b2e-8973-94decf3cc4ab" />

*Ans: CMP*

**Q5. What is the correct pin code?**

the correct pin as in the instruction `CMP eax 0x20b3` which compare our input to `0x20b3` (8371 in decimal). Test this with the binary

<img width="1022" height="245" alt="image" src="https://github.com/user-attachments/assets/b0338692-0e6d-479b-b284-76892c41271e" />

*Ans: 8371*

**Q6. Find the value to be printed on the command line with “printf” in the function by setting up the value of the EIP register as the address of the function named "letsdefend".**

first you need to quit and reload the binary again into the GDB, then break at the main function and run it. Keep executing the ni command till you see the printf function, once you see it, view the address of the letsdefend function so we can set the next instruction to it. 

```bash
gdb-peda$ info function letsdefend
All functions matching regular expression "letsdefend":

Non-debugging symbols:
0x565561b9  letsdefend
```

Set the instruction pointer for the function letsdefend before the call to the printf function

```bash
gdb-peda$ set $eip=0x565561b9
```

Then continue executing the `ni`command and you will see that it is now executing the function letsdefend and printf will print Welcome string as seen in the output below

<img width="1333" height="783" alt="image" src="https://github.com/user-attachments/assets/5cd5b944-e955-4fc7-8350-211bf66efe26" />

*Ans: Welcome*
